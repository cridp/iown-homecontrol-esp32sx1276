/*
 Copyright (c) 2024. CRIDP https://github.com/cridp

 Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
 You may obtain a copy of the License at :

  http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and limitations under the License.
 */

#include <MQTTHelper.h>
#include <Arduino.h>
#include <user_config.h>
//#include <TickerUsESP32.h>
//TickerUsESP32 MQTT_tick;

void /*mqttHelper::*/messageReceived(String &topic, String &payload) {
    Serial.printf("MQTT: %s - %s", topic, payload);
    // if (topic.equals("iown/snifferOnly"))    {
    //     if (payload.equalsIgnoreCase("on"))        {
    //       snifferOnly = true;    //fsm.trigger(ACTION_ON);
    //     }
    //     else if (payload.equalsIgnoreCase("off"))        {
    //       snifferOnly = false;  //fsm.trigger(ACTION_OFF);
    //     }
    // }

    // if (topic.equals("iown/setTemp")) {
    //   mqttData = {0x0c, 0x61, 0x01, 0x03, 0xFF, 0x00};
    //   int temp = 10 * payload.toFloat();
    //   mqttData[4] = temp;
    //   snifferOnly = false;
    //   count = 12; discoverReceived = false;
    // //      snifferOnly = true;
    // }
    // if (topic.equals("iown/setPresence1")) {
    //   mqttData = {0x0c, 0x61, 0x01, 0x10, 0x01}; //0c61 0105 00/01
    //   snifferOnly = false;
    //   count = 12; discoverReceived = false;
    // //      snifferOnly = true;
    // }

    // if (topic.equals("iown/powerOn")) {
    //   mqttData = {0x0c, 0x60, 0x01, 0x2c};
    //   snifferOnly = false;
    //   count = 12; discoverReceived = false;
    // //      snifferOnly = true;
    // }
    // if (topic.equals(topic_power_set))    {
    //     if (payload.equalsIgnoreCase("on"))        {
    //         fsm.trigger(ACTION_ON);
    //     }
    //     else if (payload.equalsIgnoreCase("off"))        {
    //         fsm.trigger(ACTION_OFF);
    //     }
    // }
    // else if (topic.equals(topic_debug))    {
    //     if (payload.equalsIgnoreCase("empty"))        {
    //         fsm.trigger(ACTION_EMPTY);
    //     }
    //     if (payload.equalsIgnoreCase("clear_average"))        {
    //         clearAverage();
    //     }
    //}

    // Note: Do not use the client in the callback to publish, subscribe or
    // unsubscribe as it may cause deadlocks when other things arrive while
    // sending and receiving acknowledgments. Instead, change a global variable,
    // or push to a queue and handle it in the loop after calling `client.loop()`.
}

void /*mqttHelper::*/Connect() {
    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASSWD);
    byte mac[6];
    WiFi.macAddress(mac);
    Serial.printf("MAC: %02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    if (WiFi.waitForConnectResult() == WL_CONNECTED) {
        Serial.printf(" IP Address: ");
        Serial.println(WiFi.localIP()); 
        
        Serial.print("Connecting to MQTT ");

//        this->mqttClient.begin(MQTT_SERVER, wifi);

  //while (!this->mqttClient.connect("iown", "user", "passwd")) {
  //  Serial.print(".");
  //  delay(1000);
  //}
        //this->mqttClient.connect("iown", MQTT_USER, MQTT_PASSWD);
        // this->mqttClient.onMessage(messageReceived);
        // //mqttClient.subscribe("iown/snifferOnly");
        // this->mqttClient.subscribe("iown/powerOn");
        // this->mqttClient.subscribe("iown/setTemp");
        // this->mqttClient.subscribe("iown/setPresence");

        Serial.println("Connected");
    }
//        mqttHelper::MQTT_tick.attach_ms(500, mqttHelper::mqtt_tick);
}


